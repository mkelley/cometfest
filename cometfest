#!/usr/bin/env python
#
# v1.0.0 Written by Michael S. Kelley, UMD, Aug 2011
#
# v1.1.0 Added ability to read HORIZONS ephemeris files.  Revamped
#        output to include more columns.  MSK, 03 Sep 2011
#
from __future__ import print_function
import os
import math
import optparse 
import re
import urllib2

######################################################################
def findcol(header, colname, length):
    """Return the slice that corresponds to the position of the column
    name + length, or an empty slice if colname is not found."""
    i = header.find(colname)
    if i >= 0:
        return slice(i, i + length)
    else:
        return slice(0, 0)

######################################################################
def getcol(line, col):
    """Return the column specified by the slice col, formatted to a
    specificed width.  Replace empty columns or "n.a." with "-999"."""
    l = col.stop - col.start + 1
    s = "{0:{1}}".format(line[col], l).replace("\n", '')
    s = s.replace(" " * l, "{0:^{1}}".format("-999", l))
    s = s.replace("n.a.", "-999")
    return [s]

######################################################################
def packedNumber(number):
    """Convert a number into a 2-digit packed MPC number."""
    if len(number) > 2:
        letter = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'
        i = int(number[:len(number)-1]) - 10
        return letter[i] + number[2:]
    else:
        return "{0:02}".format(int(number))

######################################################################
def desg2mpc(name):
    """Convert a comet designation into a packed MPC comet
    designation."""
    name = name.upper()
    periodicFormat = re.compile('([0-9]{1,4})([PD])(-[A-Z]+){0,1}')
    m = periodicFormat.findall(name)
    if len(m) > 0:
        return "{0:04d}P".format(int(m[0][0]))

    provFormat = re.compile('([PCDX])/([12][890])([0-9][0-9])\s([A-Z]{1,2})([0-9]{1,3})(-[A-Z]+)*')
    m = provFormat.findall(name)
    if len(m) > 0:
        comtype, century, year, letter, number, fragment = m[0]
        packedDesg = comtype

        if century == '18':
            packedDesg += 'I'
        elif century == '19':
            packedDesg += 'J'
        elif century == '20':
            packedDesg += 'K'

        packedDesg += year


        if len(letter) == 1:
            packedDesg += letter
            packedDesg += packedNumber(number)
            if len(fragment) > 0:
                packedDesg += fragment[1].lower()
            else:
                packedDesg += '0'
        else:
            packedDesg += letter[0]
            packedDesg += packedNumber(number)
            if len(letter) == 2:
                packedDesg += letter[1]

    return packedDesg

######################################################################
def ephFromMPC(comet):
    """First, check if there is a file ephemeris, else download an
    ephemeris file from the MPC and return date, rh, delta, phase."""
    packedDesg = desg2mpc(comet)
    fn = "{0}.dat".format(packedDesg)
    flag = False
    date = []
    rh = []
    delta = []
    phase = []
    radec = []
    m1 = []
    m2 = []
    elong = []

    if not os.path.exists(fn):
        print("# Downloading ephemeris from MPC and saving to file {0}".format(fn))
        url = 'http://scully.cfa.harvard.edu/cgi-bin/returnprepeph.cgi?d=c&o={0}'.format(packedDesg)
        url = urllib2.urlopen(url)
        dump = url.readlines()
        url.close()

        outf = open(fn, 'w')
        for line in dump:
            if line.find("Date    TT") >= 0:
                flag = True
            elif line.find("</pre>") >= 0:
                flag = False
            if flag:
                outf.write(line)
        outf.close()
    else:
        print("# Reading ephemeris from file {0}".format(fn))

    inf = open(fn, 'r')
    for line in inf.readlines():
        if line.find("Date    TT") >= 0:
            datecol = findcol(line, "Date", 10)
            radeccol = findcol(line, "R. A.", 20)
            m1col = findcol(line, " m1", 4)
            m2col = findcol(line, " m2", 4)
            rhcol = findcol(line, "    r", 7)
            deltacol = findcol(line, " Delta", 7)
            elongcol = findcol(line, "Elong", 5)
            phasecol = findcol(line, "Phase", 5)
            flag = True
        elif line.find("</pre>") >= 0:
            flag = False

        if flag:
            date += getcol(line, datecol)
            radec += getcol(line, radeccol)
            m1 += getcol(line, m1col)
            m2 += getcol(line, m2col)
            rh += getcol(line, rhcol)
            delta += getcol(line, deltacol)
            elong += getcol(line, elongcol)
            phase += getcol(line, phasecol)
    inf.close()

    date = [date[0].replace('Date  ', '# Date')] + date[1:]
    return date, radec, rh, delta, phase, elong, m1, m2

######################################################################
def ephFromHORIZONS(fn):
    """Read an ephemeris from saved HORIZONS output."""
    flag = False
    date = []
    rh = []
    delta = []
    phase = []
    radec = []
    m1 = []
    m2 = []
    elong = []

    print("# Reading ephemeris from file {0}".format(fn))
    inf = open(fn, 'r')
    for line in inf.readlines():
        if line.find("Date__(UT)__HR:MN") >= 0:
            datecol = findcol(line, "Date__(UT)__HR:MN", 17)
            radeccol = findcol(line, "R.A.", 23)
            m1col = findcol(line, "T-mag", 5)
            m2col = findcol(line, "N-mag", 5)
            rhcol = findcol(line, "             r", 14)
            deltacol = findcol(line, "           delta", 16)
            elongcol = findcol(line, "  S-O-T", 7)
            phasecol = findcol(line, "  S-T-O", 7)
            flag = True
        elif line[0] == '*':
            # The first line after the column labels is full of stars,
            # skip it
            flag = False
        elif line.find("$$SOE") >= 0:
            flag = True
            continue
        elif line.find("$$EOE") >= 0:
            flag = False

        if flag:
            date += getcol(line, datecol)
            radec += getcol(line, radeccol)
            m1 += getcol(line, m1col)
            m2 += getcol(line, m2col)
            rh += getcol(line, rhcol)
            delta += getcol(line, deltacol)
            elong += getcol(line, elongcol)
            phase += getcol(line, phasecol)

    date = [date[0].replace('Date__', '# Date')] + date[1:]
    inf.close()
    return date, radec, rh, delta, phase, elong, m1, m2

######################################################################
def Planck(w, T):
    """Planck function, w in micron, T in Kelvin, returns Jy/sr"""
    c = 299792458.0       # m / s
    c1 = 3.972894922e-25  # 2 h c
    c2 = 1.438768660e-2  # h c / k
    wave = w * 1e-6  # um to m
    a = math.exp(c2 / wave / T)
    bb = c1 / (wave**3 * (a - 1.0))  # J / s / m2 / sr / Hz
    return bb * 1e26  # Jy/sr

######################################################################
def solarflux(wave):
    """Compute solar flux at 1 AU from Planck fits to the E490 solar
    spectrum, wave in micron, returns Jy.

    ASTM, 2000. Standard Solar Constant and Air Mass Zero Solar
    Spectral Irradiance Tables, Standard E490-00, American Society for
    Testing and Materials, West Conshohocken, PA. DOI:
    10.1520/E0490-00A
    """

    # Effective temperature and scale factors for specific wavelength
    # ranges, determined by fitting a scaled Planck function to the
    # E490 solar spectrum.  Constant factors are off by 1e-6
    wr = [0.25, 0.3, 0.4, 0.6, 1.0, 3, 15, 1000]
    T = [4314.61197745,   3481.34463333,   5423.31619964,   5647.24199052,
         5956.22455712,   5603.4862923 ,  15713.71462831,   5567.2174255 ]
    C = [456.14811902,  10406.45036821,     81.24840108,     80.85349485,
          61.69931996,     80.06401576,     19.205273  ,     54.43270809]
    for i in range(len(wr)):
        if wave < wr[i]:
            break
    return Planck(wave, T[i]) * C[i] * 1e-6  # Jy

######################################################################
def Phi(phase):
    """The comet scattering phase function approximation from
    Kolokolova et al. 2004, Comets II."""
    poly = [1.00920684,
            -0.030960895700000001,
            0.00073425552100000004,
            -7.8471425500000002e-06,
            3.1410548899999999e-08]
    phi = 0.0
    for n, a in enumerate(poly):
        phi += a * phase**n
    return phi

######################################################################
def fest(rh, delta, phase, wave, tscale, meana, rap, afrho1, slope):
    """Thermal emission + scattered light in Jy.

    rh, delta in AU
    phase in degrees
    wave in micron
    rap in arcsec
    afrho1 in cm

    """

    # thermal emission
    afrho = afrho1 * rh**-slope
    T = 278. * tscale / math.sqrt(rh)
    deltacm = delta * 1.49597870691e13
    A = Phi(0) * 0.7655 * meana
    B = Planck(wave, T)

    Fem = (1.0 - meana) * afrho / A * math.pi * B
    Fem *= rap / 206265.0 / deltacm

    # scattered light
    Fsca = afrho * Phi(phase) / 4.0 / deltacm
    Fsca *= rap / 206265.0 * solarflux(wave) / rh**2

    return Fem + Fsca

######################################################################
# parse command line options
parser = optparse.OptionParser(
    usage="""usage: %prog [options] <file or designation>

where <file> is the name of a saved JPL HORIZONS ephemeris file or
<designation> = 2P, 101P, "C/2009 P1", etc. to download an ephemeris
from the Minor Planet Center.  NOTE that the output columns will
likely be in an order different from the MPC and HORIZONS formats.

When generating HORIZONS ephemerides, select columns (1 or 2), 9, 19,
20, 23, and 24, or "small-body geocentric".

The program uses many approximations in order to be fast and concise.
Estimates at wavelengths less than 0.4 um are especially poor.  For
the most part, the approximations are good to 10%, and the method is
good to a factor of 4.""", version="%prog 1.1.0")
parser.add_option('-w', '--wavelength', default='5,10,20',
                  help='the wavelength(s), micron (comma separated) [5,10,20]')
parser.add_option('-t', '--tscale', type=float, default=1.1,
                  help='the temperature scale factor [1.1]')
parser.add_option('--meana', type=float, default=0.32,
                  help='the mean bolometric albedo [0.32]')
parser.add_option('-r', '--rap', type=float, default=0.5,
                  help='aperture radius, arcsec [0.5]')
parser.add_option('-a', '--afrho', type=float, default=100,
                  help='Afrho at 1 AU, cm [100]')
parser.add_option('-k', '--slope', type=float, default=2.3,
                  help='Afrho slope: rh**-k [2.3]')
options, args = parser.parse_args()

# print help, if the user needs it
if len(args) != 1:
    parser.print_help()
    exit(0)

# setup wavelengths and column formats
wave = options.wavelength.split(',')
w = [float(x) for x in wave]
cwidth = [max(len(x) + 4, 9) for x in wave]
cformat = ["  {{0:{0}.4g}}".format(x) for x in cwidth]
clabels = ["{0:^{1}}".format("F({0})".format(x), y)
           for x, y in zip(wave, cwidth)]
clabels = "  ".join(clabels)

# MPC or HORIZONS ephemeris?
if os.path.exists(args[0]):
    # HORIZONS
    eph = ephFromHORIZONS(args[0])
else:
    # MPC
    eph = ephFromMPC(args[0])

# compute fluxes and print
for date, radec, rh, delta, phase, elong, m1, m2 in zip(*eph):
    if date[0] == '#':
        print("""#
# Afrho at 1 AU = {0} cm
# Afrho scales with rh**-{1}
# Effective temperature = {2} * 278 / sqrt(rh)
# Mean bolometric albedo = {3}
# Aperture radius = {4}"
#
# -999 is a flag for missing data
#""".format(options.afrho, options.slope, options.tscale, options.meana,
            options.rap))
        print(date, radec, rh, delta, phase, elong, m1, m2, clabels,
              sep='  ')
    else:
        print(date, radec, rh, delta, phase, elong, m1, m2, sep='  ',
              end='')
        for i in range(len(wave)):
                # compute the flux for this line in the ephemeris
            F = fest(float(rh), float(delta), float(phase), w[i],
                     options.tscale, options.meana, options.rap,
                     options.afrho, options.slope)
            print(cformat[i].format(F), end='')
        print()
